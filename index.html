<!doctype html>
<html lang="en">

<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
  <title>seti</title>
  <meta name="description" content="Create and Trade real-world events on Seti." />
  <meta name="author" content="Seti" />

  <meta property="og:title" content="Seti" />
  <meta property="og:description" content="Create and Trade on real-world events with Seti." />
  <meta property="og:type" content="website" />
  <link rel="icon" type="image/svg+xml" href="/seti_.svg" />
  <link rel="icon" type="image/x-icon" href="/seti_.ico" />

  <meta property="og:image" content="/og-image.svg" />

  <meta name="twitter:card" content="summary_large_image" />
  <meta name="twitter:site" content="@seti" />
  <meta name="twitter:image" content="/og-image.svg" />
</head>

<body>
  <div id="root"></div>
  <script>
    // Buffer polyfill - must be applied before any modules load
    if (typeof globalThis.Buffer === 'undefined') {
      // Create a comprehensive Buffer polyfill
      function BufferPolyfill(data, encoding) {
        if (typeof data === 'string') {
          if (encoding === 'hex') {
            const hex = data.replace(/[^0-9a-fA-F]/g, '');
            const bytes = new Uint8Array(hex.length / 2);
            for (let i = 0; i < hex.length; i += 2) {
              bytes[i / 2] = parseInt(hex.substr(i, 2), 16);
            }
            return bytes;
          }
          return new TextEncoder().encode(data);
        }
        return new Uint8Array(data);
      }
      
      BufferPolyfill.from = function(data, encoding) {
        return new BufferPolyfill(data, encoding);
      };
      
      BufferPolyfill.isBuffer = function(obj) {
        return obj instanceof Uint8Array;
      };
      
      BufferPolyfill.alloc = function(size, fill) {
        const buffer = new Uint8Array(size);
        if (fill !== undefined) {
          buffer.fill(fill);
        }
        return buffer;
      };
      
      BufferPolyfill.concat = function(list, totalLength) {
        const total = totalLength || list.reduce((acc, item) => acc + item.length, 0);
        const result = new Uint8Array(total);
        let offset = 0;
        for (const item of list) {
          result.set(item, offset);
          offset += item.length;
        }
        return result;
      };
      
      // Add prototype methods
      BufferPolyfill.prototype = Uint8Array.prototype;
      BufferPolyfill.prototype.toString = function(encoding) {
        if (encoding === 'hex') {
          return Array.from(this).map(b => b.toString(16).padStart(2, '0')).join('');
        }
        return new TextDecoder().decode(this);
      };
      
      globalThis.Buffer = BufferPolyfill;
    }
    
    // Process polyfill
    if (typeof globalThis.process === 'undefined') {
      globalThis.process = {
        env: {},
        version: '',
        platform: 'browser',
        nextTick: function(fn) {
          Promise.resolve().then(fn);
        }
      };
    }
  </script>
  <script type="module" src="/src/main.tsx"></script>
</body>

</html>